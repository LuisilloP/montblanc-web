---
import GoogleG from "../icons/GoogleG.astro";
import reviewsData from "../../data/montblanc.reviews.json";

type Review = {
  author: string;
  avatar: string | null;
  rating: number;
  relativeTime: string;
  text: string;
  source?: string;
};

type ReviewsData = {
  placeName: string;
  googleUrl?: string;
  reviews: Review[];
};

const { data = reviewsData as ReviewsData } = Astro.props as { data?: ReviewsData };
const instanceId = `google-reviews-${Math.random().toString(36).slice(2, 8)}`;
const baseReviews = data.reviews || [];
const enableLoop = false;
const hasLoop = enableLoop && baseReviews.length > 1;
const loopedReviews = hasLoop ? [baseReviews[baseReviews.length - 1], ...baseReviews, baseReviews[0]] : baseReviews;
const startIndex = hasLoop ? 1 : 0;

const getInitial = (name: string) => (name?.trim()?.charAt(0) || "?").toUpperCase();
---

<section id="resenas" class="relative overflow-hidden py-16 lg:py-24">
  <div class="pointer-events-none absolute inset-0 opacity-70">
    <div class="absolute inset-0 bg-[radial-gradient(circle_at_20%_20%,rgba(255,255,255,0.55),transparent_32%),radial-gradient(circle_at_82%_12%,rgba(230,214,198,0.6),transparent_28%),var(--bg-noise)]" />
  </div>

  <div class="container-wide relative space-y-10">
    <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
      <div class="space-y-2">
        <p class="text-[11px] font-semibold uppercase tracking-[0.24em] text-[var(--goldLight)]">Reseñas de Google</p>
        <h2 class="text-3xl font-semibold text-[var(--charcoal)] sm:text-4xl">{data.placeName}</h2>
        <p class="text-base text-[var(--charcoal)]/70">Reseñas reales de pacientes</p>
      </div>
      {data.googleUrl && (
        <a
          href={data.googleUrl}
          class="inline-flex items-center gap-2 rounded-full bg-white px-4 py-2 text-sm font-semibold text-[var(--charcoal)] shadow-[0_10px_35px_rgba(32,32,32,0.08)] ring-1 ring-[rgba(32,32,32,0.06)] transition hover:-translate-y-[1px] hover:shadow-[0_14px_40px_rgba(32,32,32,0.12)]"
          target="_blank"
          rel="noopener noreferrer"
        >
          <GoogleG size={16} />
          Ver en Google
        </a>
      )}
    </div>

    <div class="relative reviews-shell">
      <div
        id={instanceId}
        class="hide-scrollbar reviews-track relative z-10 flex snap-x snap-mandatory gap-6 overflow-x-auto scroll-smooth pb-5 pt-3 cursor-grab"
        role="region"
        aria-label={`Reseñas de ${data.placeName}`}
        style="touch-action: pan-x pan-y;"
        data-base-count={baseReviews.length}
        data-has-loop={hasLoop ? "true" : "false"}
        data-start-index={startIndex}
      >
        {loopedReviews.map((review) => (
          <article
            class="snap-start basis-[88%] shrink-0 cursor-pointer sm:basis-[68%] md:basis-[48%] lg:basis-[32%]"
            data-card
          >
            <div class="flex h-full min-h-[260px] flex-col rounded-[20px] border border-[rgba(32,32,32,0.06)] bg-white/95 p-6 shadow-[0_18px_46px_rgba(0,0,0,0.08)] backdrop-blur-[2px]">
              <div class="flex items-start justify-between gap-3">
                <div class="flex items-center gap-3">
                  {review.avatar ? (
                    <img src={review.avatar} alt={`Avatar de ${review.author}`} class="h-10 w-10 rounded-full object-cover shadow-sm" loading="lazy" />
                  ) : (
                    <div class="flex h-10 w-10 items-center justify-center rounded-full bg-[rgba(32,32,32,0.08)] text-sm font-semibold text-[var(--charcoal)] shadow-inner">
                      {getInitial(review.author)}
                    </div>
                  )}
                  <div>
                    <p class="text-base font-semibold leading-tight text-[var(--charcoal)]">{review.author}</p>
                    <p class="text-xs text-[var(--charcoal)]/60">{review.relativeTime}</p>
                  </div>
                </div>
                <div class="rounded-full bg-white/90 p-2 shadow-[0_8px_24px_rgba(32,32,32,0.12)] ring-1 ring-[rgba(32,32,32,0.06)]">
                  <GoogleG size={18} />
                </div>
              </div>

              <div class="mt-3 flex items-center gap-1 text-[#fbbc04]">
                {Array.from({ length: 5 }).map((_, idx) => (
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    class={`h-4 w-4 ${idx < review.rating ? "opacity-100" : "opacity-30"}`}
                    fill="currentColor"
                    aria-hidden="true"
                  >
                    <path d="M10 2l2.09 4.26L17 7.27l-3.5 3.41.83 4.85L10 13.77l-4.33 2.76.83-4.85L3 7.27l4.91-.99L10 2z" />
                  </svg>
                ))}
              </div>

              <p class="clamp-4 mt-3 text-[15px] leading-relaxed text-[var(--charcoal)]/80">{review.text}</p>

              <div class="mt-auto flex items-center justify-between pt-4 text-xs text-[var(--charcoal)]/60">
                <span class="flex items-center gap-2">
                  <span class="h-2 w-2 rounded-full bg-[#fbbc04]" />
                  {review.source || "Google"}
                </span>
                <span class="rounded-full bg-[rgba(32,32,32,0.04)] px-3 py-1 text-[11px] font-semibold uppercase tracking-[0.16em] text-[var(--charcoal)]/70">
                  5.0 / 5
                </span>
              </div>
            </div>
          </article>
        ))}
      </div>

      <div class="pointer-events-none absolute left-0 right-0 top-1/2 hidden -translate-y-1/2 items-center justify-between reviews-nav-wrap md:flex">
        <button
          id={`${instanceId}-prev`}
          class="reviews-nav-btn pointer-events-auto"
          aria-label="Anterior reseña"
          type="button"
          data-dir="prev"
        >
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="h-5 w-5" fill="currentColor" aria-hidden="true">
            <path fill-rule="evenodd" d="M12.78 15.53a.75.75 0 01-1.06 0l-4.25-4.25a.75.75 0 010-1.06l4.25-4.25a.75.75 0 111.06 1.06L8.56 10l4.22 4.22a.75.75 0 010 1.06z" clip-rule="evenodd" />
          </svg>
        </button>
        <button
          id={`${instanceId}-next`}
          class="reviews-nav-btn pointer-events-auto"
          aria-label="Siguiente reseña"
          type="button"
          data-dir="next"
        >
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="h-5 w-5" fill="currentColor" aria-hidden="true">
            <path fill-rule="evenodd" d="M7.22 4.47a.75.75 0 011.06 0l4.25 4.25a.75.75 0 010 1.06l-4.25 4.25a.75.75 0 01-1.06-1.06L11.44 10 7.22 5.78a.75.75 0 010-1.06z" clip-rule="evenodd" />
          </svg>
        </button>
      </div>
    </div>
  </div>
</section>

<style is:global>
  .hide-scrollbar {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .hide-scrollbar::-webkit-scrollbar {
    display: none;
  }

  .clamp-4 {
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .is-dragging {
    cursor: grabbing;
    user-select: none;
    -webkit-user-select: none;
  }

  .reviews-shell {
    --edge-pad: clamp(18px, 6vw, 72px);
    --fade: clamp(14px, 6vw, 56px);
  }

  .reviews-track {
    padding-left: var(--edge-pad);
    padding-right: var(--edge-pad);
    scroll-padding-left: var(--edge-pad);
    scroll-padding-right: var(--edge-pad);
    -webkit-mask-image: linear-gradient(
      90deg,
      transparent 0px,
      #000 var(--fade),
      #000 calc(100% - var(--fade)),
      transparent 100%
    );
    mask-image: linear-gradient(
      90deg,
      transparent 0px,
      #000 var(--fade),
      #000 calc(100% - var(--fade)),
      transparent 100%
    );
  }

  .reviews-nav-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 48px;
    width: 48px;
    border-radius: 9999px;
    color: var(--charcoal);
    background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.8)) padding-box,
      linear-gradient(145deg, rgba(255, 255, 255, 0.85), rgba(230, 214, 198, 0.55)) border-box;
    border: 1px solid rgba(32, 32, 32, 0.05);
    box-shadow:
      0 18px 38px rgba(32, 32, 32, 0.16),
      0 2px 8px rgba(32, 32, 32, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.75);
    backdrop-filter: blur(6px);
    transition: transform 180ms ease, box-shadow 180ms ease, background 180ms ease;
  }

  .reviews-nav-btn:hover {
    transform: translateY(-1px) scale(1.02);
    box-shadow:
      0 20px 42px rgba(32, 32, 32, 0.2),
      0 6px 14px rgba(32, 32, 32, 0.12),
      inset 0 1px 0 rgba(255, 255, 255, 0.9);
  }

  .reviews-nav-btn:active {
    transform: translateY(0) scale(0.99);
    box-shadow:
      0 12px 28px rgba(32, 32, 32, 0.16),
      inset 0 1px 0 rgba(255, 255, 255, 0.8);
  }

  .reviews-nav-btn:focus-visible {
    outline: 2px solid rgba(230, 214, 198, 0.9);
    outline-offset: 3px;
  }

  .reviews-nav-wrap {
    padding-left: max(16px, calc(var(--edge-pad) - 48px));
    padding-right: max(16px, calc(var(--edge-pad) - 48px));
    z-index: 20;
  }

  @media (min-width: 1024px) {
    .reviews-shell {
      --edge-pad: clamp(72px, 8vw, 140px);
      --fade: clamp(70px, 10vw, 180px);
    }

    .reviews-shell::before,
    .reviews-shell::after {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      width: clamp(70px, 14vw, 220px);
      pointer-events: none;
      z-index: 15;
    }

    .reviews-shell::before {
      left: 0;
      background: linear-gradient(90deg, rgba(248, 240, 232, 0.9), rgba(248, 240, 232, 0.35), transparent);
    }

    .reviews-shell::after {
      right: 0;
      background: linear-gradient(270deg, rgba(248, 240, 232, 0.9), rgba(248, 240, 232, 0.35), transparent);
    }
  }

  @media (max-width: 640px) {
    .reviews-shell {
      --card-width: min(92vw, 460px);
      --edge-pad: calc((100vw - var(--card-width)) / 2);
      --fade: 0px;
    }

    .reviews-track {
      gap: 18px;
      padding-left: var(--edge-pad);
      padding-right: var(--edge-pad);
      scroll-padding-left: var(--edge-pad);
      scroll-padding-right: var(--edge-pad);
      -webkit-mask-image: none;
      mask-image: none;
    }

    .reviews-track [data-card] {
      flex-basis: var(--card-width);
      scroll-snap-align: center;
    }
  }
</style>

<script define:vars={{ instanceId }}>
  const setupCarousel = () => {
    const carousel = document.getElementById(instanceId);
    if (!carousel) return;

    const cards = Array.from(carousel.querySelectorAll("[data-card]"));
    const totalCards = cards.length;
    if (!totalCards) return;

    const baseCount = Number(carousel.dataset.baseCount || totalCards);
    const hasLoop = carousel.dataset.hasLoop === "true" && baseCount > 1;
    const startIndex = Number(carousel.dataset.startIndex || 0);

    const prevButton = document.getElementById(`${instanceId}-prev`);
    const nextButton = document.getElementById(`${instanceId}-next`);

    const LOOP_THRESHOLD = 0.35;

    const getBaseOffset = () => {
      const style = window.getComputedStyle(carousel);
      return parseFloat(style.paddingLeft || "0") || 0;
    };

    const getStep = () => {
      const firstCard = carousel.querySelector("[data-card]");
      if (!firstCard) return carousel.clientWidth * 0.9;
      const rect = firstCard.getBoundingClientRect();
      const style = window.getComputedStyle(carousel);
      const gap = parseFloat(style.columnGap || style.gap || "0") || 0;
      return rect.width + gap;
    };

    let currentIndex = startIndex;

    const scrollToIndex = (index, behavior = "smooth") => {
      const step = getStep() || carousel.clientWidth * 0.9;
      const boundedIndex = Math.max(0, Math.min(index, totalCards - 1));
      const baseOffset = getBaseOffset();
      const target = baseOffset + boundedIndex * step;
      currentIndex = boundedIndex;
      carousel.scrollTo({ left: target, behavior });
    };

    const setInitialPosition = () => {
      const step = getStep() || carousel.clientWidth * 0.9;
      const baseOffset = getBaseOffset();
      const target = baseOffset + startIndex * step;
      carousel.scrollTo({ left: target, behavior: "auto" });
      currentIndex = startIndex;
    };

    requestAnimationFrame(setInitialPosition);

    const scrollByStep = (direction = 1) => {
      scrollToIndex(currentIndex + direction);
    };

    prevButton?.addEventListener("click", () => scrollByStep(-1));
    nextButton?.addEventListener("click", () => scrollByStep(1));

    carousel.addEventListener("keydown", (event) => {
      if (event.key === "ArrowRight") {
        event.preventDefault();
        scrollByStep(1);
      } else if (event.key === "ArrowLeft") {
        event.preventDefault();
        scrollByStep(-1);
      }
    });

    carousel.addEventListener(
      "wheel",
      (event) => {
        if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
          carousel.scrollBy({ left: event.deltaY, behavior: "smooth" });
          event.preventDefault();
        }
      },
      { passive: false }
    );

    let syncTimer;
    carousel.addEventListener("scroll", () => {
      window.clearTimeout(syncTimer);
      syncTimer = window.setTimeout(() => {
        const step = getStep() || carousel.clientWidth * 0.9;
        const baseOffset = getBaseOffset();
        const rawIndex = (carousel.scrollLeft - baseOffset) / step;
        const nearStartClone = rawIndex < LOOP_THRESHOLD;
        const nearEndClone = rawIndex > totalCards - 1 - LOOP_THRESHOLD;
        if (hasLoop) {
          if (nearStartClone) {
            scrollToIndex(totalCards - 2, "auto");
            currentIndex = totalCards - 2;
            return;
          }
          if (nearEndClone) {
            scrollToIndex(1, "auto");
            currentIndex = 1;
            return;
          }
        }
        currentIndex = Math.round(rawIndex);
      }, 80);
    });

    let isDragging = false;
    let dragged = false;
    let startX = 0;
    let startY = 0;
    let startScroll = 0;
    let previousUserSelect = "";
    const DRAG_THRESHOLD = 4;
    const VERTICAL_ESCAPE = 12;

    const setUserSelect = (value) => {
      document.body.style.userSelect = value;
      document.body.style.webkitUserSelect = value;
    };

    const stopDrag = (event) => {
      if (!isDragging) return;
      isDragging = false;
      carousel.classList.remove("is-dragging");
      carousel.style.scrollSnapType = "";
      carousel.style.scrollBehavior = "";
      setUserSelect(previousUserSelect);
      if (dragged && event) {
        event.preventDefault();
        event.stopPropagation();
      }
      const step = getStep() || carousel.clientWidth * 0.9;
      const baseOffset = getBaseOffset();
      const rawIndex = (carousel.scrollLeft - baseOffset) / step;
      const nearStartClone = rawIndex < LOOP_THRESHOLD;
      const nearEndClone = rawIndex > totalCards - 1 - LOOP_THRESHOLD;
      if (hasLoop) {
        if (nearStartClone) {
          scrollToIndex(totalCards - 2, "auto");
          dragged = false;
          currentIndex = totalCards - 2;
          return;
        } else if (nearEndClone) {
          scrollToIndex(1, "auto");
          dragged = false;
          currentIndex = 1;
          return;
        }
      }
      currentIndex = Math.round(rawIndex);
      scrollToIndex(currentIndex);
      dragged = false;
    };

    const onPointerDown = (event) => {
      if (event.pointerType === "mouse" && event.button !== 0) return;
      isDragging = true;
      dragged = false;
      startX = event.clientX ?? 0;
      startY = event.clientY ?? 0;
      startScroll = carousel.scrollLeft;
      previousUserSelect = document.body.style.userSelect || "";
      setUserSelect("none");
      carousel.classList.add("is-dragging");
      carousel.style.scrollSnapType = "none";
      carousel.style.scrollBehavior = "auto";
      carousel.setPointerCapture?.(event.pointerId);
    };

    const onPointerMove = (event) => {
      if (!isDragging) return;
      const clientX = event.clientX ?? 0;
      const clientY = event.clientY ?? 0;
      const deltaX = clientX - startX;
      const deltaY = clientY - startY;

      if (!dragged) {
        const verticalDominant = Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > VERTICAL_ESCAPE;
        if (verticalDominant) {
          stopDrag();
          return;
        }
        if (Math.abs(deltaX) <= DRAG_THRESHOLD) return;
      }

      dragged = true;
      event.preventDefault();
      carousel.scrollLeft = startScroll - deltaX;
    };

    const onPointerUp = (event) => stopDrag(event);

    carousel.addEventListener("pointerdown", onPointerDown);
    document.addEventListener("pointermove", onPointerMove, { passive: false });
    document.addEventListener("pointerup", onPointerUp);
    document.addEventListener("pointercancel", onPointerUp);
    document.addEventListener("pointerleave", onPointerUp);

    carousel.addEventListener(
      "click",
      (event) => {
        if (dragged) {
          event.preventDefault();
          event.stopPropagation();
          dragged = false;
        }
      },
      true
    );
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", setupCarousel, { once: true });
  } else {
    setupCarousel();
  }
</script>
