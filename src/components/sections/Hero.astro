---
type Stat = { value: string; label: string };

type VideoConfig = {
  webm?: string;
  mp4?: string;
  src?: string;
  poster?: string;
};

type Props = {
  data: {
    eyebrow?: string;
    title?: string;
    titleLines?: string[];
    subtitle?: string;
    note?: string;
    primaryCta: { label: string; href: string; ariaLabel?: string };
    secondaryCta: { label: string; href: string; ariaLabel?: string };
    stats?: Stat[];
    video?: VideoConfig;
  };
};

const { data } = Astro.props as Props;
const stats = data.stats ?? [];
const titleLines =
  data.titleLines && data.titleLines.length > 0
    ? data.titleLines
    : data.title
      ? [data.title]
      : [];
const titleLine1 = titleLines[0] ?? "";
const titleLine2 = titleLines[1];
const heroEyebrow = data.eyebrow ?? "";
const heroSubtitle = data.subtitle ?? "";
const heroNote = data.note ?? "";
const primaryLabel = data.primaryCta.label;
const secondaryLabel = data.secondaryCta.label;
const primaryAria = data.primaryCta.ariaLabel ?? primaryLabel;
const secondaryAria = data.secondaryCta.ariaLabel ?? secondaryLabel;
const hasEyebrow = Boolean(heroEyebrow);
const hasSubtitle = Boolean(heroSubtitle);
const hasNote = Boolean(heroNote);
const posterSrc =
  data.video?.poster ?? "data:image/gif;base64,R0lGODlhAQABAAAAACw=";
const inferType = (src: string | undefined) => {
  if (!src) return undefined;
  const lower = src.toLowerCase();
  if (lower.endsWith(".webm")) return "video/webm";
  if (lower.endsWith(".mp4")) return "video/mp4";
  return undefined;
};
const videoSources = [
  data.video?.webm ? { src: data.video.webm, type: "video/webm" } : null,
  data.video?.mp4 ? { src: data.video.mp4, type: "video/mp4" } : null,
  data.video?.src
    ? { src: data.video.src, type: inferType(data.video.src) }
    : null,
].filter(Boolean) as { src: string; type?: string }[];
const hasVideo = videoSources.length > 0;
---

<section id="inicio" class="">
  <div class="absolute inset-0">
    <div
      class="absolute inset-0 bg-cover bg-center hero-fallback"
      aria-hidden="true"
    >
    </div>
    {
      hasVideo && (
        <video
          class="hero-video pointer-events-none absolute inset-0 h-full w-full object-cover opacity-95"
          poster={posterSrc}
          autoplay
          muted
          loop
          playsinline
          preload="metadata"
          aria-hidden="true"
        >
          {videoSources.map((source) => (
            <source src={source.src} type={source.type} />
          ))}
        </video>
      )
    }
    <div
      class="absolute inset-0 bg-linear-to-tr from-[rgba(12,8,4,0.82)] via-[rgba(12,8,4,0.5)] to-[rgba(240,226,214,0.18)]"
    >
    </div>
    <div
      class="pointer-events-none absolute inset-x-0 bottom-0 h-[52%] bg-linear-to-t from-[rgba(10,6,4,0.82)] via-[rgba(10,6,4,0.55)] to-transparent"
    >
    </div>
  </div>

  <div
    class="relative z-10 flex min-h-[82vh] sm:min-h-[86vh] lg:min-h-[92vh] flex-col justify-end"
  >
    <div
      class="px-5 pb-28 pt-16 sm:px-8 sm:pb-32 sm:pt-16 lg:px-16 lg:pb-36 lg:pt-20"
    >
      <div class="max-w-screen-sm space-y-3 sm:space-y-4 lg:space-y-5">
        {hasEyebrow && (
          <p
            class="hero-eyebrow text-[10px] uppercase tracking-[0.32em] sm:text-[11px]"
          >
            {heroEyebrow}
          </p>
        )}
        <h1
          class="hero-title hero-title-shadow font-(--font-heading) text-[34px] leading-[1.05] sm:text-[42px] lg:text-[54px]"
        >
          {titleLine1}
          {titleLine2 && (
            <>
              <br />
              <span class="text-[#d4b894]">{titleLine2}</span>
            </>
          )}
        </h1>
        {hasSubtitle && (
          <p
            class="hero-sub-shadow max-w-xl text-base leading-relaxed text-[rgba(248,240,232,0.88)] sm:text-lg"
          >
            {heroSubtitle}
          </p>
        )}
        <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:gap-4">
          <a
            class="btn-primary w-full sm:w-auto focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-(--goldLight) focus-visible:ring-offset-2 focus-visible:ring-offset-[rgba(12,8,4,0.7)]"
            href={data.primaryCta.href}
            aria-label={primaryAria}
            target="_blank"
            rel="noreferrer"
          >
            {primaryLabel}
          </a>
          <a
            class="btn-secondary w-full sm:w-auto focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-(--goldLight) focus-visible:ring-offset-2 focus-visible:ring-offset-[rgba(12,8,4,0.7)]"
            href={data.secondaryCta.href}
            aria-label={secondaryAria}
          >
            {secondaryLabel}
          </a>
        </div>
        {hasNote && (
          <p
            class="text-xs uppercase tracking-[0.12em] text-[rgba(248,240,232,0.72)] sm:text-[13px]"
          >
            {heroNote}
          </p>
        )}
      </div>
    </div>
  </div>

  {
    stats.length > 0 && (
      <div class="pointer-events-none absolute inset-x-0 bottom-0 z-20">
        <div class="pointer-events-auto w-full bg-[rgba(12,8,4,0.48)] backdrop-blur-sm">
          <div class="mx-auto max-w-6xl px-5 py-4 sm:px-8 sm:py-5">
            <div class="grid grid-cols-2 gap-y-4 text-center text-[rgba(248,240,232,0.95)] sm:grid-cols-4 sm:gap-y-0 sm:divide-x sm:divide-[rgba(248,240,232,0.14)]">
              {stats.map((stat) => (
                <div class="flex flex-col items-center gap-1">
                  <span
                    class="stat-number font-(--font-heading) text-3xl leading-tight sm:text-4xl lg:text-[44px]"
                    data-target={stat.value}
                  >
                    {stat.value}
                  </span>
                  <span class="text-xs font-medium tracking-wide text-[rgba(248,240,232,0.76)] sm:text-sm">
                    {stat.label}
                  </span>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    )
  }

  <style>
    @media (prefers-reduced-motion: reduce) {
      .hero-video {
        display: none !important;
      }
    }

    @keyframes countFadeIn {
      from {
        opacity: 0.4;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .stat-number {
      animation: countFadeIn 0.6s ease forwards;
    }

    .hero-video {
      object-position: 50% 30%;
    }

    @media (min-width: 640px) {
      .hero-video {
        object-position: 50% 30%;
      }
    }

    .hero-title-shadow {
      text-shadow: 0 6px 30px rgba(0, 0, 0, 0.35);
    }

    .hero-sub-shadow {
      text-shadow: 0 4px 18px rgba(0, 0, 0, 0.28);
    }

    .hero-title {
      color: #ffffff !important;
      letter-spacing: 0;
    }

    .hero-eyebrow {
      color: #f3e7d4 !important;
    }

    .hero-fallback {
      background-image:
        radial-gradient(
          circle at 32% 44%,
          rgba(10, 8, 6, 0.22),
          rgba(10, 8, 6, 0.1) 30%,
          rgba(10, 8, 6, 0) 60%
        ),
        linear-gradient(
          180deg,
          rgba(12, 10, 8, 0.6) 0%,
          rgba(12, 10, 8, 0.32) 42%,
          rgba(12, 10, 8, 0.16) 64%,
          rgba(12, 10, 8, 0) 82%
        );
      background-color: #0f0c08;
    }
  </style>

  <script>
    const parseTarget = (raw: string | null) => {
      const value = String(raw ?? "0");
      const target = Number(value.replace(/[^\d]/g, "")) || 0;
      const suffix = value.replace(/[\d\s]/g, "");
      return { target, suffix };
    };

    const animateCounts = () => {
      const stats = document.querySelectorAll(".stat-number");

      const run = (el: Element) => {
        const { target, suffix } = parseTarget(el.getAttribute("data-target"));
        const startValue =
          target > 10 ? Math.max(1, Math.floor(target * 0.05)) : 0;
        const duration = 2000;
        const startedAt = performance.now();

        const step = (now: number) => {
          const progress = Math.min((now - startedAt) / duration, 1);
          const current = Math.floor(
            startValue + (target - startValue) * progress
          );
          el.textContent = current.toLocaleString("en-US") + suffix;
          if (progress < 1) requestAnimationFrame(step);
        };

        requestAnimationFrame(step);
      };

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              observer.unobserve(entry.target);
              run(entry.target);
            }
          });
        },
        { threshold: 0.2 }
      );

      stats.forEach((el) => {
        const { suffix } = parseTarget(el.getAttribute("data-target"));
        el.textContent = "0" + suffix;
        observer.observe(el);
      });
    };

    if (
      document.readyState === "complete" ||
      document.readyState === "interactive"
    ) {
      animateCounts();
    } else {
      document.addEventListener("DOMContentLoaded", animateCounts);
    }
  </script>
</section>
